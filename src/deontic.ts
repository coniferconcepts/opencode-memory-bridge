/**
 * Deontic classification system for memory observations.
 * 
 * ## Rationale: Structured Knowledge Classification
 * 
 * Instead of blindly capturing all observations (including incorrect
 * "MUST" statements from AI), we classify content by:
 * 
 * 1. **Type**: Fact, Decision, or Policy Candidate
 * 2. **Authority**: Repo (highest), User, Assistant (lowest)
 * 3. **Confidence**: How certain we are about the classification
 * 
 * This enables:
 * - Filtering out low-authority policy claims
 * - Prioritizing repo-level decisions over assistant suggestions
 * - Flagging policy candidates for human review
 * 
 * @module src/integrations/claude-mem/deontic
 */

import * as v from 'valibot';

// =============================================================================
// Classification Types
// =============================================================================

/**
 * Content classification types.
 * 
 * - **Fact**: Objective, verifiable information
 * - **Decision**: A choice made about implementation
 * - **PolicyCandidate**: A suggested rule/constraint (needs review)
 */
export type ContentType = 'fact' | 'decision' | 'policy-candidate';

/**
 * Authority tiers for content sources.
 * 
 * - **Repo**: From repository files (CLAUDE.md, ADRs, etc.)
 * - **User**: Explicitly stated by the user
 * - **Assistant**: Generated by AI assistant
 */
export type AuthorityTier = 'repo' | 'user' | 'assistant';

/**
 * Deontic classification result.
 */
export interface DeonticClassification {
  /** The classified content type */
  type: ContentType;
  /** The authority tier of the source */
  authority: AuthorityTier;
  /** Confidence score (0-1) */
  confidence: number;
  /** Reasoning for the classification */
  reasoning: string;
  /** Whether this should be flagged for review */
  needsReview: boolean;
}

// =============================================================================
// Classification Schema
// =============================================================================

/**
 * Deontic classification schema
 */
export const DeonticClassificationSchema = v.object({
  type: v.picklist(['fact', 'decision', 'policy-candidate']),
  authority: v.picklist(['repo', 'user', 'assistant']),
  confidence: v.pipe(v.number(), v.minValue(0), v.maxValue(1)),
  reasoning: v.string(),
  needsReview: v.boolean(),
});

// =============================================================================
// Deontic Markers
// =============================================================================

/**
 * Patterns that indicate policy/rule statements.
 */
const POLICY_MARKERS = [
  /\bMUST\b/,
  /\bMUST NOT\b/,
  /\bSHOULD\b/,
  /\bSHOULD NOT\b/,
  /\bSHALL\b/,
  /\bSHALL NOT\b/,
  /\bREQUIRED\b/,
  /\bPROHIBITED\b/,
  /\bMANDATORY\b/,
  /\bNEVER\b/,
  /\bALWAYS\b/,
];

/**
 * Patterns that indicate factual statements.
 */
const FACT_MARKERS = [
  /\bis\b/,
  /\bare\b/,
  /\bwas\b/,
  /\bwere\b/,
  /\bhas\b/,
  /\bhave\b/,
  /\bcontains\b/,
  /\breturns\b/,
  /\baccepts\b/,
];

/**
 * Patterns that indicate decision statements.
 */
const DECISION_MARKERS = [
  /\bdecided\b/i,
  /\bchose\b/i,
  /\bselected\b/i,
  /\bwill use\b/i,
  /\bgoing with\b/i,
  /\bimplemented\b/i,
  /\badopted\b/i,
];

// =============================================================================
// Classification Functions
// =============================================================================

/**
 * Detect the authority tier based on source metadata.
 * 
 * @param source - The source identifier
 * @param filePath - Optional file path for repo-level detection
 */
export function detectAuthority(
  source: string,
  filePath?: string
): AuthorityTier {
  // Repo-level sources
  if (filePath) {
    const repoFiles = [
      'CLAUDE.md',
      'AGENTS.md',
      'ADR-',
      '.claude/',
      'docs/',
    ];
    if (repoFiles.some(pattern => filePath.includes(pattern))) {
      return 'repo';
    }
  }
  
  // User-level sources
  if (source === 'user' || source === 'human') {
    return 'user';
  }
  
  // Default to assistant
  return 'assistant';
}

/**
 * Classify content using heuristic analysis.
 * 
 * @param content - The content to classify
 * @param source - The source identifier
 * @param filePath - Optional file path
 */
export function classifyContent(
  content: string,
  source: string,
  filePath?: string
): DeonticClassification {
  const authority = detectAuthority(source, filePath);
  
  // Check for policy markers
  const hasPolicyMarkers = POLICY_MARKERS.some(pattern => pattern.test(content));
  const hasDecisionMarkers = DECISION_MARKERS.some(pattern => pattern.test(content));
  const hasFactMarkers = FACT_MARKERS.some(pattern => pattern.test(content));
  
  // Determine type
  let type: ContentType;
  let confidence: number;
  let reasoning: string;
  
  if (hasPolicyMarkers) {
    type = 'policy-candidate';
    confidence = 0.8;
    reasoning = 'Contains deontic markers (MUST, SHOULD, etc.)';
  } else if (hasDecisionMarkers) {
    type = 'decision';
    confidence = 0.7;
    reasoning = 'Contains decision language (decided, chose, etc.)';
  } else if (hasFactMarkers) {
    type = 'fact';
    confidence = 0.6;
    reasoning = 'Contains factual language (is, has, returns, etc.)';
  } else {
    type = 'fact';
    confidence = 0.5;
    reasoning = 'Default classification (no strong markers)';
  }
  
  // Determine if review is needed
  // Policy candidates from assistants need review
  const needsReview = type === 'policy-candidate' && authority === 'assistant';
  
  return {
    type,
    authority,
    confidence,
    reasoning,
    needsReview,
  };
}

/**
 * Filter observations based on deontic classification.
 * 
 * **Filtering Rules:**
 * - Always include repo-level content
 * - Always include user-level content
 * - Include assistant facts and decisions
 * - Flag assistant policy candidates for review (don't auto-include)
 * 
 * @param classification - The deontic classification
 * @returns Whether to include this observation
 */
export function shouldIncludeObservation(
  classification: DeonticClassification
): boolean {
  // Always include repo and user content
  if (classification.authority === 'repo' || classification.authority === 'user') {
    return true;
  }
  
  // Include assistant facts and decisions
  if (classification.type === 'fact' || classification.type === 'decision') {
    return true;
  }
  
  // Don't auto-include assistant policy candidates
  // These should be flagged for review
  return false;
}

/**
 * Get the priority score for an observation.
 * 
 * Higher scores = higher priority in retrieval.
 * 
 * @param classification - The deontic classification
 */
export function getObservationPriority(
  classification: DeonticClassification
): number {
  // Authority weight (repo > user > assistant)
  const authorityWeight = {
    repo: 1.0,
    user: 0.8,
    assistant: 0.5,
  }[classification.authority];
  
  // Type weight (decisions > facts > policy candidates)
  const typeWeight = {
    decision: 1.0,
    fact: 0.8,
    'policy-candidate': 0.3,
  }[classification.type];
  
  return authorityWeight * typeWeight * classification.confidence;
}
